#' Simulate time-to-event data
#'
#' @description Generates survival time and status fields using hazard and censoring as inputs
#'
#' @param INPUTS - hazard and censoring distributions as generated by etsim_inputs()
#'
<<<<<<< HEAD
#' @details Times to event are defined as \eqn{t = \min( t_h, t_C)},
#' where \eqn{t_h} is the time to hazard (distributed according to the input \eqn{S_h})
#' and \eqn{t_C} is the time to censoring (distributed according to the input \eqn{S_{censoring}})
=======
#' @details Times to event are defined as \eqn{t = min( t_h, t_C)}, where \eqn{t_h} is the time to hazard (distributed according to the input \eqn{S_h}) and \eqn{t_c} is the time to censoring (distributed according to the input \eqn{S_{censoring}})
>>>>>>> 3697aae2f514a41f3e8d7b8c09fa6a002ad982c5
#'
#' @return Returns a list of outputs (time, status, entry)
#'
#'     t = array of times to event
#'     status = 0 if alive at time t, 1 otherwise
#'     entry = NULL [IS IT OK TO IGNORE LATE ENTRY AT THIS STAGE?]
#' @importFrom stats runif
<<<<<<< HEAD
#' @importFrom pracma interp1
#' @export
#'
#' @examples
#'     #Generate input for a b-spline hazard and piecewise exponential survival censoring
=======
#' @export
#'
#' @examples
#'     #First, we generate input for a b-spline hazard simulation with piecewise exponential survival censoring
>>>>>>> 3697aae2f514a41f3e8d7b8c09fa6a002ad982c5
#'     knots = c(0, 1, 3, 6, 10, NA, NA)
#'     betac = 1 * c(0.05, 0.05, 0.05, 0.05, 0.40, 0.1, 0.05)
#'     HParm = data.frame(knots, betac) # 'A Simple B-Spline'
#'     cll = c(0, 5)
#'     cup = c(5, 10)
#'     cih = c(0.0125, 0.025)
#'     CParm = data.frame(cll, cup, cih) # 'Light Censoring'
#'     INPUTS = etsim_inputs( HParam=HParm, CParam=CParm)
#'
#'     #Then, we can generate the time-to event data
#'     SimDat = etsim(INPUTS)
#'     table( SimDat$status )
#'
etsim <- function( INPUTS ){

  ## Simulate hazard time
  unif_x = INPUTS$Sh[ order(INPUTS$Sh) ]
  unif_y = INPUTS$t[ order(INPUTS$Sh) ]
  # sel = setdiff( 1:length(INPUTS$t), which( unif_x[-length(unif_x)] == unif_x[-1] ) ) #duplicated values in unif_x
  # unif_x = unif_x[ sel ]
  # unif_y = INPUTS$t[ sel ]
  unif   = runif( n=length(INPUTS$t), min=0, max=1 )
  time = rep( NA, length(unif) ) ##time will be censored if outside the observation domain
  sel = which( unif >= min(unif_x) & unif <= max(unif_x) )
  time[sel]   = interp1( unif_x, unif_y, unif[sel], method="linear" )

  ## Simulate censoring time
  unif_x = INPUTS$Scensor[ order(INPUTS$Scensor) ]
  unif_y = INPUTS$t[ order(INPUTS$Scensor) ]
  # sel = setdiff( 1:length(INPUTS$t), which( unif_x[-length(unif_x)] == unif_x[-1] ) ) #we remove duplicated values in unif_x
  # unif_x = unif_x[ sel ]
  # unif_y = INPUTS$t[ sel ]
  unif   = runif( n=length(INPUTS$t), min=0, max=1 )
  timeCensor = rep( NA, length(unif) )
  sel = which( unif >= min(unif_x) & unif <= max(unif_x) )
  timeCensor[sel]   = interp1( unif_x, unif_y, unif[sel], method="linear" )

  ## Simulate the observed time and status
  y0 = pmin( time, timeCensor, na.rm = TRUE)
  y0 = pmin( y0, max(INPUTS$t), na.rm = TRUE )
  status = rep(1, length(time))   #status=1 means no censoring
  status[ !is.na(timeCensor) & !is.na(time) & timeCensor < time ] = 0 #status=0 means censoring
  status[ is.na(time) | (time > max(INPUTS$t)) ] = 0

  return( list(
    time=y0,
    status=status,
    entry=NULL ##nothing to assign for the moment
  ))
}
